import {
  MDCRipple,
  MDCRippleFoundation
} from "./chunk-E3K7WDLC.js";
import {
  applyPassive
} from "./chunk-2QYY3AJL.js";
import {
  closest,
  matches
} from "./chunk-PWEMLQJ7.js";
import {
  MDCComponent,
  MDCFoundation,
  __assign,
  __awaiter,
  __extends,
  __generator,
  __values
} from "./chunk-2UTNIWRO.js";
import "./chunk-JC4IRQUL.js";

// node_modules/@material/animation/util.js
var cssPropertyNameMap = {
  animation: {
    prefixed: "-webkit-animation",
    standard: "animation"
  },
  transform: {
    prefixed: "-webkit-transform",
    standard: "transform"
  },
  transition: {
    prefixed: "-webkit-transition",
    standard: "transition"
  }
};
var jsEventTypeMap = {
  animationend: {
    cssProperty: "animation",
    prefixed: "webkitAnimationEnd",
    standard: "animationend"
  },
  animationiteration: {
    cssProperty: "animation",
    prefixed: "webkitAnimationIteration",
    standard: "animationiteration"
  },
  animationstart: {
    cssProperty: "animation",
    prefixed: "webkitAnimationStart",
    standard: "animationstart"
  },
  transitionend: {
    cssProperty: "transition",
    prefixed: "webkitTransitionEnd",
    standard: "transitionend"
  }
};
function isWindow(windowObj) {
  return Boolean(windowObj.document) && typeof windowObj.document.createElement === "function";
}
function getCorrectPropertyName(windowObj, cssProperty) {
  if (isWindow(windowObj) && cssProperty in cssPropertyNameMap) {
    var el = windowObj.document.createElement("div");
    var _a = cssPropertyNameMap[cssProperty], standard = _a.standard, prefixed = _a.prefixed;
    var isStandard = standard in el.style;
    return isStandard ? standard : prefixed;
  }
  return cssProperty;
}
function getCorrectEventName(windowObj, eventType) {
  if (isWindow(windowObj) && eventType in jsEventTypeMap) {
    var el = windowObj.document.createElement("div");
    var _a = jsEventTypeMap[eventType], standard = _a.standard, prefixed = _a.prefixed, cssProperty = _a.cssProperty;
    var isStandard = cssProperty in el.style;
    return isStandard ? standard : prefixed;
  }
  return eventType;
}

// node_modules/@material/checkbox/constants.js
var cssClasses = {
  ANIM_CHECKED_INDETERMINATE: "mdc-checkbox--anim-checked-indeterminate",
  ANIM_CHECKED_UNCHECKED: "mdc-checkbox--anim-checked-unchecked",
  ANIM_INDETERMINATE_CHECKED: "mdc-checkbox--anim-indeterminate-checked",
  ANIM_INDETERMINATE_UNCHECKED: "mdc-checkbox--anim-indeterminate-unchecked",
  ANIM_UNCHECKED_CHECKED: "mdc-checkbox--anim-unchecked-checked",
  ANIM_UNCHECKED_INDETERMINATE: "mdc-checkbox--anim-unchecked-indeterminate",
  BACKGROUND: "mdc-checkbox__background",
  CHECKED: "mdc-checkbox--checked",
  CHECKMARK: "mdc-checkbox__checkmark",
  CHECKMARK_PATH: "mdc-checkbox__checkmark-path",
  DISABLED: "mdc-checkbox--disabled",
  INDETERMINATE: "mdc-checkbox--indeterminate",
  MIXEDMARK: "mdc-checkbox__mixedmark",
  NATIVE_CONTROL: "mdc-checkbox__native-control",
  ROOT: "mdc-checkbox",
  SELECTED: "mdc-checkbox--selected",
  UPGRADED: "mdc-checkbox--upgraded"
};
var strings = {
  ARIA_CHECKED_ATTR: "aria-checked",
  ARIA_CHECKED_INDETERMINATE_VALUE: "mixed",
  DATA_INDETERMINATE_ATTR: "data-indeterminate",
  NATIVE_CONTROL_SELECTOR: ".mdc-checkbox__native-control",
  TRANSITION_STATE_CHECKED: "checked",
  TRANSITION_STATE_INDETERMINATE: "indeterminate",
  TRANSITION_STATE_INIT: "init",
  TRANSITION_STATE_UNCHECKED: "unchecked"
};
var numbers = {
  ANIM_END_LATCH_MS: 250
};

// node_modules/@material/checkbox/foundation.js
var MDCCheckboxFoundation = function(_super) {
  __extends(MDCCheckboxFoundation2, _super);
  function MDCCheckboxFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCCheckboxFoundation2.defaultAdapter), adapter)) || this;
    _this.currentCheckState = strings.TRANSITION_STATE_INIT;
    _this.currentAnimationClass = "";
    _this.animEndLatchTimer = 0;
    _this.enableAnimationEndHandler = false;
    return _this;
  }
  Object.defineProperty(MDCCheckboxFoundation2, "cssClasses", {
    get: function() {
      return cssClasses;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCCheckboxFoundation2, "strings", {
    get: function() {
      return strings;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCCheckboxFoundation2, "numbers", {
    get: function() {
      return numbers;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCCheckboxFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        forceLayout: function() {
          return void 0;
        },
        hasNativeControl: function() {
          return false;
        },
        isAttachedToDOM: function() {
          return false;
        },
        isChecked: function() {
          return false;
        },
        isIndeterminate: function() {
          return false;
        },
        removeClass: function() {
          return void 0;
        },
        removeNativeControlAttr: function() {
          return void 0;
        },
        setNativeControlAttr: function() {
          return void 0;
        },
        setNativeControlDisabled: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCCheckboxFoundation2.prototype.init = function() {
    this.currentCheckState = this.determineCheckState();
    this.updateAriaChecked();
    this.adapter.addClass(cssClasses.UPGRADED);
  };
  MDCCheckboxFoundation2.prototype.destroy = function() {
    clearTimeout(this.animEndLatchTimer);
  };
  MDCCheckboxFoundation2.prototype.setDisabled = function(disabled) {
    this.adapter.setNativeControlDisabled(disabled);
    if (disabled) {
      this.adapter.addClass(cssClasses.DISABLED);
    } else {
      this.adapter.removeClass(cssClasses.DISABLED);
    }
  };
  MDCCheckboxFoundation2.prototype.handleAnimationEnd = function() {
    var _this = this;
    if (!this.enableAnimationEndHandler) {
      return;
    }
    clearTimeout(this.animEndLatchTimer);
    this.animEndLatchTimer = setTimeout(function() {
      _this.adapter.removeClass(_this.currentAnimationClass);
      _this.enableAnimationEndHandler = false;
    }, numbers.ANIM_END_LATCH_MS);
  };
  MDCCheckboxFoundation2.prototype.handleChange = function() {
    this.transitionCheckState();
  };
  MDCCheckboxFoundation2.prototype.transitionCheckState = function() {
    if (!this.adapter.hasNativeControl()) {
      return;
    }
    var oldState = this.currentCheckState;
    var newState = this.determineCheckState();
    if (oldState === newState) {
      return;
    }
    this.updateAriaChecked();
    var TRANSITION_STATE_UNCHECKED = strings.TRANSITION_STATE_UNCHECKED;
    var SELECTED = cssClasses.SELECTED;
    if (newState === TRANSITION_STATE_UNCHECKED) {
      this.adapter.removeClass(SELECTED);
    } else {
      this.adapter.addClass(SELECTED);
    }
    if (this.currentAnimationClass.length > 0) {
      clearTimeout(this.animEndLatchTimer);
      this.adapter.forceLayout();
      this.adapter.removeClass(this.currentAnimationClass);
    }
    this.currentAnimationClass = this.getTransitionAnimationClass(oldState, newState);
    this.currentCheckState = newState;
    if (this.adapter.isAttachedToDOM() && this.currentAnimationClass.length > 0) {
      this.adapter.addClass(this.currentAnimationClass);
      this.enableAnimationEndHandler = true;
    }
  };
  MDCCheckboxFoundation2.prototype.determineCheckState = function() {
    var TRANSITION_STATE_INDETERMINATE = strings.TRANSITION_STATE_INDETERMINATE, TRANSITION_STATE_CHECKED = strings.TRANSITION_STATE_CHECKED, TRANSITION_STATE_UNCHECKED = strings.TRANSITION_STATE_UNCHECKED;
    if (this.adapter.isIndeterminate()) {
      return TRANSITION_STATE_INDETERMINATE;
    }
    return this.adapter.isChecked() ? TRANSITION_STATE_CHECKED : TRANSITION_STATE_UNCHECKED;
  };
  MDCCheckboxFoundation2.prototype.getTransitionAnimationClass = function(oldState, newState) {
    var TRANSITION_STATE_INIT = strings.TRANSITION_STATE_INIT, TRANSITION_STATE_CHECKED = strings.TRANSITION_STATE_CHECKED, TRANSITION_STATE_UNCHECKED = strings.TRANSITION_STATE_UNCHECKED;
    var _a = MDCCheckboxFoundation2.cssClasses, ANIM_UNCHECKED_CHECKED = _a.ANIM_UNCHECKED_CHECKED, ANIM_UNCHECKED_INDETERMINATE = _a.ANIM_UNCHECKED_INDETERMINATE, ANIM_CHECKED_UNCHECKED = _a.ANIM_CHECKED_UNCHECKED, ANIM_CHECKED_INDETERMINATE = _a.ANIM_CHECKED_INDETERMINATE, ANIM_INDETERMINATE_CHECKED = _a.ANIM_INDETERMINATE_CHECKED, ANIM_INDETERMINATE_UNCHECKED = _a.ANIM_INDETERMINATE_UNCHECKED;
    switch (oldState) {
      case TRANSITION_STATE_INIT:
        if (newState === TRANSITION_STATE_UNCHECKED) {
          return "";
        }
        return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
      case TRANSITION_STATE_UNCHECKED:
        return newState === TRANSITION_STATE_CHECKED ? ANIM_UNCHECKED_CHECKED : ANIM_UNCHECKED_INDETERMINATE;
      case TRANSITION_STATE_CHECKED:
        return newState === TRANSITION_STATE_UNCHECKED ? ANIM_CHECKED_UNCHECKED : ANIM_CHECKED_INDETERMINATE;
      default:
        return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
    }
  };
  MDCCheckboxFoundation2.prototype.updateAriaChecked = function() {
    if (this.adapter.isIndeterminate()) {
      this.adapter.setNativeControlAttr(strings.ARIA_CHECKED_ATTR, strings.ARIA_CHECKED_INDETERMINATE_VALUE);
    } else {
      this.adapter.removeNativeControlAttr(strings.ARIA_CHECKED_ATTR);
    }
  };
  return MDCCheckboxFoundation2;
}(MDCFoundation);

// node_modules/@material/checkbox/component.js
var CB_PROTO_PROPS = ["checked", "indeterminate"];
var MDCCheckbox = function(_super) {
  __extends(MDCCheckbox2, _super);
  function MDCCheckbox2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.rippleSurface = _this.createRipple();
    return _this;
  }
  MDCCheckbox2.attachTo = function(root) {
    return new MDCCheckbox2(root);
  };
  Object.defineProperty(MDCCheckbox2.prototype, "ripple", {
    get: function() {
      return this.rippleSurface;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCCheckbox2.prototype, "checked", {
    get: function() {
      return this.getNativeControl().checked;
    },
    set: function(checked) {
      this.getNativeControl().checked = checked;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCCheckbox2.prototype, "indeterminate", {
    get: function() {
      return this.getNativeControl().indeterminate;
    },
    set: function(indeterminate) {
      this.getNativeControl().indeterminate = indeterminate;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCCheckbox2.prototype, "disabled", {
    get: function() {
      return this.getNativeControl().disabled;
    },
    set: function(disabled) {
      this.foundation.setDisabled(disabled);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCCheckbox2.prototype, "value", {
    get: function() {
      return this.getNativeControl().value;
    },
    set: function(value) {
      this.getNativeControl().value = value;
    },
    enumerable: false,
    configurable: true
  });
  MDCCheckbox2.prototype.initialize = function() {
    var DATA_INDETERMINATE_ATTR = strings.DATA_INDETERMINATE_ATTR;
    this.getNativeControl().indeterminate = this.getNativeControl().getAttribute(DATA_INDETERMINATE_ATTR) === "true";
    this.getNativeControl().removeAttribute(DATA_INDETERMINATE_ATTR);
  };
  MDCCheckbox2.prototype.initialSyncWithDOM = function() {
    var _this = this;
    this.handleChange = function() {
      _this.foundation.handleChange();
    };
    this.handleAnimationEnd = function() {
      _this.foundation.handleAnimationEnd();
    };
    this.getNativeControl().addEventListener("change", this.handleChange);
    this.listen(getCorrectEventName(window, "animationend"), this.handleAnimationEnd);
    this.installPropertyChangeHooks();
  };
  MDCCheckbox2.prototype.destroy = function() {
    this.rippleSurface.destroy();
    this.getNativeControl().removeEventListener("change", this.handleChange);
    this.unlisten(getCorrectEventName(window, "animationend"), this.handleAnimationEnd);
    this.uninstallPropertyChangeHooks();
    _super.prototype.destroy.call(this);
  };
  MDCCheckbox2.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      addClass: function(className) {
        return _this.root.classList.add(className);
      },
      forceLayout: function() {
        return _this.root.offsetWidth;
      },
      hasNativeControl: function() {
        return !!_this.getNativeControl();
      },
      isAttachedToDOM: function() {
        return Boolean(_this.root.parentNode);
      },
      isChecked: function() {
        return _this.checked;
      },
      isIndeterminate: function() {
        return _this.indeterminate;
      },
      removeClass: function(className) {
        _this.root.classList.remove(className);
      },
      removeNativeControlAttr: function(attr) {
        _this.getNativeControl().removeAttribute(attr);
      },
      setNativeControlAttr: function(attr, value) {
        _this.getNativeControl().setAttribute(attr, value);
      },
      setNativeControlDisabled: function(disabled) {
        _this.getNativeControl().disabled = disabled;
      }
    };
    return new MDCCheckboxFoundation(adapter);
  };
  MDCCheckbox2.prototype.createRipple = function() {
    var _this = this;
    var adapter = __assign(__assign({}, MDCRipple.createAdapter(this)), { deregisterInteractionHandler: function(evtType, handler) {
      _this.getNativeControl().removeEventListener(evtType, handler, applyPassive());
    }, isSurfaceActive: function() {
      return matches(_this.getNativeControl(), ":active");
    }, isUnbounded: function() {
      return true;
    }, registerInteractionHandler: function(evtType, handler) {
      _this.getNativeControl().addEventListener(evtType, handler, applyPassive());
    } });
    return new MDCRipple(this.root, new MDCRippleFoundation(adapter));
  };
  MDCCheckbox2.prototype.installPropertyChangeHooks = function() {
    var e_1, _a;
    var _this = this;
    var nativeCb = this.getNativeControl();
    var cbProto = Object.getPrototypeOf(nativeCb);
    var _loop_1 = function(controlState2) {
      var desc = Object.getOwnPropertyDescriptor(cbProto, controlState2);
      if (!validDescriptor(desc)) {
        return { value: void 0 };
      }
      var nativeGetter = desc.get;
      var nativeCbDesc = {
        configurable: desc.configurable,
        enumerable: desc.enumerable,
        get: nativeGetter,
        set: function(state) {
          desc.set.call(nativeCb, state);
          _this.foundation.handleChange();
        }
      };
      Object.defineProperty(nativeCb, controlState2, nativeCbDesc);
    };
    try {
      for (var CB_PROTO_PROPS_1 = __values(CB_PROTO_PROPS), CB_PROTO_PROPS_1_1 = CB_PROTO_PROPS_1.next(); !CB_PROTO_PROPS_1_1.done; CB_PROTO_PROPS_1_1 = CB_PROTO_PROPS_1.next()) {
        var controlState = CB_PROTO_PROPS_1_1.value;
        var state_1 = _loop_1(controlState);
        if (typeof state_1 === "object")
          return state_1.value;
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (CB_PROTO_PROPS_1_1 && !CB_PROTO_PROPS_1_1.done && (_a = CB_PROTO_PROPS_1.return))
          _a.call(CB_PROTO_PROPS_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  };
  MDCCheckbox2.prototype.uninstallPropertyChangeHooks = function() {
    var e_2, _a;
    var nativeCb = this.getNativeControl();
    var cbProto = Object.getPrototypeOf(nativeCb);
    try {
      for (var CB_PROTO_PROPS_2 = __values(CB_PROTO_PROPS), CB_PROTO_PROPS_2_1 = CB_PROTO_PROPS_2.next(); !CB_PROTO_PROPS_2_1.done; CB_PROTO_PROPS_2_1 = CB_PROTO_PROPS_2.next()) {
        var controlState = CB_PROTO_PROPS_2_1.value;
        var desc = Object.getOwnPropertyDescriptor(cbProto, controlState);
        if (!validDescriptor(desc)) {
          return;
        }
        Object.defineProperty(nativeCb, controlState, desc);
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (CB_PROTO_PROPS_2_1 && !CB_PROTO_PROPS_2_1.done && (_a = CB_PROTO_PROPS_2.return))
          _a.call(CB_PROTO_PROPS_2);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
  };
  MDCCheckbox2.prototype.getNativeControl = function() {
    var NATIVE_CONTROL_SELECTOR = strings.NATIVE_CONTROL_SELECTOR;
    var el = this.root.querySelector(NATIVE_CONTROL_SELECTOR);
    if (!el) {
      throw new Error("Checkbox component requires a " + NATIVE_CONTROL_SELECTOR + " element");
    }
    return el;
  };
  return MDCCheckbox2;
}(MDCComponent);
function validDescriptor(inputPropDesc) {
  return !!inputPropDesc && typeof inputPropDesc.set === "function";
}

// node_modules/@material/linear-progress/constants.js
var cssClasses2 = {
  CLOSED_CLASS: "mdc-linear-progress--closed",
  CLOSED_ANIMATION_OFF_CLASS: "mdc-linear-progress--closed-animation-off",
  INDETERMINATE_CLASS: "mdc-linear-progress--indeterminate",
  REVERSED_CLASS: "mdc-linear-progress--reversed",
  ANIMATION_READY_CLASS: "mdc-linear-progress--animation-ready"
};
var strings2 = {
  ARIA_HIDDEN: "aria-hidden",
  ARIA_VALUEMAX: "aria-valuemax",
  ARIA_VALUEMIN: "aria-valuemin",
  ARIA_VALUENOW: "aria-valuenow",
  BUFFER_BAR_SELECTOR: ".mdc-linear-progress__buffer-bar",
  FLEX_BASIS: "flex-basis",
  PRIMARY_BAR_SELECTOR: ".mdc-linear-progress__primary-bar"
};
var animationDimensionPercentages = {
  PRIMARY_HALF: 0.8367142,
  PRIMARY_FULL: 2.00611057,
  SECONDARY_QUARTER: 0.37651913,
  SECONDARY_HALF: 0.84386165,
  SECONDARY_FULL: 1.60277782
};

// node_modules/@material/linear-progress/foundation.js
var MDCLinearProgressFoundation = function(_super) {
  __extends(MDCLinearProgressFoundation2, _super);
  function MDCLinearProgressFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCLinearProgressFoundation2.defaultAdapter), adapter)) || this;
    _this.observer = null;
    return _this;
  }
  Object.defineProperty(MDCLinearProgressFoundation2, "cssClasses", {
    get: function() {
      return cssClasses2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCLinearProgressFoundation2, "strings", {
    get: function() {
      return strings2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCLinearProgressFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        attachResizeObserver: function() {
          return null;
        },
        forceLayout: function() {
          return void 0;
        },
        getWidth: function() {
          return 0;
        },
        hasClass: function() {
          return false;
        },
        setBufferBarStyle: function() {
          return null;
        },
        setPrimaryBarStyle: function() {
          return null;
        },
        setStyle: function() {
          return void 0;
        },
        removeAttribute: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        setAttribute: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCLinearProgressFoundation2.prototype.init = function() {
    var _this = this;
    this.determinate = !this.adapter.hasClass(cssClasses2.INDETERMINATE_CLASS);
    this.adapter.addClass(cssClasses2.ANIMATION_READY_CLASS);
    this.progress = 0;
    this.buffer = 1;
    this.observer = this.adapter.attachResizeObserver(function(entries) {
      var e_1, _a;
      if (_this.determinate) {
        return;
      }
      try {
        for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
          var entry = entries_1_1.value;
          if (entry.contentRect) {
            _this.calculateAndSetDimensions(entry.contentRect.width);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return))
            _a.call(entries_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    });
    if (!this.determinate && this.observer) {
      this.calculateAndSetDimensions(this.adapter.getWidth());
    }
  };
  MDCLinearProgressFoundation2.prototype.setDeterminate = function(isDeterminate) {
    this.determinate = isDeterminate;
    if (this.determinate) {
      this.adapter.removeClass(cssClasses2.INDETERMINATE_CLASS);
      this.adapter.setAttribute(strings2.ARIA_VALUENOW, this.progress.toString());
      this.adapter.setAttribute(strings2.ARIA_VALUEMAX, "1");
      this.adapter.setAttribute(strings2.ARIA_VALUEMIN, "0");
      this.setPrimaryBarProgress(this.progress);
      this.setBufferBarProgress(this.buffer);
      return;
    }
    if (this.observer) {
      this.calculateAndSetDimensions(this.adapter.getWidth());
    }
    this.adapter.addClass(cssClasses2.INDETERMINATE_CLASS);
    this.adapter.removeAttribute(strings2.ARIA_VALUENOW);
    this.adapter.removeAttribute(strings2.ARIA_VALUEMAX);
    this.adapter.removeAttribute(strings2.ARIA_VALUEMIN);
    this.setPrimaryBarProgress(1);
    this.setBufferBarProgress(1);
  };
  MDCLinearProgressFoundation2.prototype.isDeterminate = function() {
    return this.determinate;
  };
  MDCLinearProgressFoundation2.prototype.setProgress = function(value) {
    this.progress = value;
    if (this.determinate) {
      this.setPrimaryBarProgress(value);
      this.adapter.setAttribute(strings2.ARIA_VALUENOW, value.toString());
    }
  };
  MDCLinearProgressFoundation2.prototype.getProgress = function() {
    return this.progress;
  };
  MDCLinearProgressFoundation2.prototype.setBuffer = function(value) {
    this.buffer = value;
    if (this.determinate) {
      this.setBufferBarProgress(value);
    }
  };
  MDCLinearProgressFoundation2.prototype.getBuffer = function() {
    return this.buffer;
  };
  MDCLinearProgressFoundation2.prototype.open = function() {
    this.adapter.removeClass(cssClasses2.CLOSED_CLASS);
    this.adapter.removeClass(cssClasses2.CLOSED_ANIMATION_OFF_CLASS);
    this.adapter.removeAttribute(strings2.ARIA_HIDDEN);
  };
  MDCLinearProgressFoundation2.prototype.close = function() {
    this.adapter.addClass(cssClasses2.CLOSED_CLASS);
    this.adapter.setAttribute(strings2.ARIA_HIDDEN, "true");
  };
  MDCLinearProgressFoundation2.prototype.isClosed = function() {
    return this.adapter.hasClass(cssClasses2.CLOSED_CLASS);
  };
  MDCLinearProgressFoundation2.prototype.handleTransitionEnd = function() {
    if (this.adapter.hasClass(cssClasses2.CLOSED_CLASS)) {
      this.adapter.addClass(cssClasses2.CLOSED_ANIMATION_OFF_CLASS);
    }
  };
  MDCLinearProgressFoundation2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    if (this.observer) {
      this.observer.disconnect();
    }
  };
  MDCLinearProgressFoundation2.prototype.restartAnimation = function() {
    this.adapter.removeClass(cssClasses2.ANIMATION_READY_CLASS);
    this.adapter.forceLayout();
    this.adapter.addClass(cssClasses2.ANIMATION_READY_CLASS);
  };
  MDCLinearProgressFoundation2.prototype.setPrimaryBarProgress = function(progressValue) {
    var value = "scaleX(" + progressValue + ")";
    var transformProp = typeof window !== "undefined" ? getCorrectPropertyName(window, "transform") : "transform";
    this.adapter.setPrimaryBarStyle(transformProp, value);
  };
  MDCLinearProgressFoundation2.prototype.setBufferBarProgress = function(progressValue) {
    var value = progressValue * 100 + "%";
    this.adapter.setBufferBarStyle(strings2.FLEX_BASIS, value);
  };
  MDCLinearProgressFoundation2.prototype.calculateAndSetDimensions = function(width) {
    var primaryHalf = width * animationDimensionPercentages.PRIMARY_HALF;
    var primaryFull = width * animationDimensionPercentages.PRIMARY_FULL;
    var secondaryQuarter = width * animationDimensionPercentages.SECONDARY_QUARTER;
    var secondaryHalf = width * animationDimensionPercentages.SECONDARY_HALF;
    var secondaryFull = width * animationDimensionPercentages.SECONDARY_FULL;
    this.adapter.setStyle("--mdc-linear-progress-primary-half", primaryHalf + "px");
    this.adapter.setStyle("--mdc-linear-progress-primary-half-neg", -primaryHalf + "px");
    this.adapter.setStyle("--mdc-linear-progress-primary-full", primaryFull + "px");
    this.adapter.setStyle("--mdc-linear-progress-primary-full-neg", -primaryFull + "px");
    this.adapter.setStyle("--mdc-linear-progress-secondary-quarter", secondaryQuarter + "px");
    this.adapter.setStyle("--mdc-linear-progress-secondary-quarter-neg", -secondaryQuarter + "px");
    this.adapter.setStyle("--mdc-linear-progress-secondary-half", secondaryHalf + "px");
    this.adapter.setStyle("--mdc-linear-progress-secondary-half-neg", -secondaryHalf + "px");
    this.adapter.setStyle("--mdc-linear-progress-secondary-full", secondaryFull + "px");
    this.adapter.setStyle("--mdc-linear-progress-secondary-full-neg", -secondaryFull + "px");
    this.restartAnimation();
  };
  return MDCLinearProgressFoundation2;
}(MDCFoundation);

// node_modules/@material/linear-progress/component.js
var MDCLinearProgress = function(_super) {
  __extends(MDCLinearProgress2, _super);
  function MDCLinearProgress2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCLinearProgress2.attachTo = function(root) {
    return new MDCLinearProgress2(root);
  };
  Object.defineProperty(MDCLinearProgress2.prototype, "determinate", {
    set: function(value) {
      this.foundation.setDeterminate(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCLinearProgress2.prototype, "progress", {
    set: function(value) {
      this.foundation.setProgress(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCLinearProgress2.prototype, "buffer", {
    set: function(value) {
      this.foundation.setBuffer(value);
    },
    enumerable: false,
    configurable: true
  });
  MDCLinearProgress2.prototype.open = function() {
    this.foundation.open();
  };
  MDCLinearProgress2.prototype.close = function() {
    this.foundation.close();
  };
  MDCLinearProgress2.prototype.initialSyncWithDOM = function() {
    var _this = this;
    this.root.addEventListener("transitionend", function() {
      _this.foundation.handleTransitionEnd();
    });
  };
  MDCLinearProgress2.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      addClass: function(className) {
        _this.root.classList.add(className);
      },
      forceLayout: function() {
        _this.root.getBoundingClientRect();
      },
      setBufferBarStyle: function(styleProperty, value) {
        var bufferBar = _this.root.querySelector(MDCLinearProgressFoundation.strings.BUFFER_BAR_SELECTOR);
        if (bufferBar) {
          bufferBar.style.setProperty(styleProperty, value);
        }
      },
      setPrimaryBarStyle: function(styleProperty, value) {
        var primaryBar = _this.root.querySelector(MDCLinearProgressFoundation.strings.PRIMARY_BAR_SELECTOR);
        if (primaryBar) {
          primaryBar.style.setProperty(styleProperty, value);
        }
      },
      hasClass: function(className) {
        return _this.root.classList.contains(className);
      },
      removeAttribute: function(attributeName) {
        _this.root.removeAttribute(attributeName);
      },
      removeClass: function(className) {
        _this.root.classList.remove(className);
      },
      setAttribute: function(attributeName, value) {
        _this.root.setAttribute(attributeName, value);
      },
      setStyle: function(name, value) {
        _this.root.style.setProperty(name, value);
      },
      attachResizeObserver: function(callback) {
        var RO = window.ResizeObserver;
        if (RO) {
          var ro = new RO(callback);
          ro.observe(_this.root);
          return ro;
        }
        return null;
      },
      getWidth: function() {
        return _this.root.offsetWidth;
      }
    };
    return new MDCLinearProgressFoundation(adapter);
  };
  return MDCLinearProgress2;
}(MDCComponent);

// node_modules/@material/data-table/constants.js
var cssClasses3 = {
  CELL: "mdc-data-table__cell",
  CELL_NUMERIC: "mdc-data-table__cell--numeric",
  CONTENT: "mdc-data-table__content",
  HEADER_CELL: "mdc-data-table__header-cell",
  HEADER_CELL_LABEL: "mdc-data-table__header-cell-label",
  HEADER_CELL_SORTED: "mdc-data-table__header-cell--sorted",
  HEADER_CELL_SORTED_DESCENDING: "mdc-data-table__header-cell--sorted-descending",
  HEADER_CELL_WITH_SORT: "mdc-data-table__header-cell--with-sort",
  HEADER_CELL_WRAPPER: "mdc-data-table__header-cell-wrapper",
  HEADER_ROW: "mdc-data-table__header-row",
  HEADER_ROW_CHECKBOX: "mdc-data-table__header-row-checkbox",
  IN_PROGRESS: "mdc-data-table--in-progress",
  LINEAR_PROGRESS: "mdc-data-table__linear-progress",
  PAGINATION_ROWS_PER_PAGE_LABEL: "mdc-data-table__pagination-rows-per-page-label",
  PAGINATION_ROWS_PER_PAGE_SELECT: "mdc-data-table__pagination-rows-per-page-select",
  PROGRESS_INDICATOR: "mdc-data-table__progress-indicator",
  ROOT: "mdc-data-table",
  ROW: "mdc-data-table__row",
  ROW_CHECKBOX: "mdc-data-table__row-checkbox",
  ROW_SELECTED: "mdc-data-table__row--selected",
  SORT_ICON_BUTTON: "mdc-data-table__sort-icon-button",
  SORT_STATUS_LABEL: "mdc-data-table__sort-status-label",
  TABLE_CONTAINER: "mdc-data-table__table-container"
};
var attributes = {
  ARIA_SELECTED: "aria-selected",
  ARIA_SORT: "aria-sort"
};
var dataAttributes = {
  COLUMN_ID: "data-column-id",
  ROW_ID: "data-row-id"
};
var selectors = {
  CONTENT: "." + cssClasses3.CONTENT,
  HEADER_CELL: "." + cssClasses3.HEADER_CELL,
  HEADER_CELL_WITH_SORT: "." + cssClasses3.HEADER_CELL_WITH_SORT,
  HEADER_ROW: "." + cssClasses3.HEADER_ROW,
  HEADER_ROW_CHECKBOX: "." + cssClasses3.HEADER_ROW_CHECKBOX,
  PROGRESS_INDICATOR: "." + cssClasses3.PROGRESS_INDICATOR,
  ROW: "." + cssClasses3.ROW,
  ROW_CHECKBOX: "." + cssClasses3.ROW_CHECKBOX,
  ROW_SELECTED: "." + cssClasses3.ROW_SELECTED,
  SORT_ICON_BUTTON: "." + cssClasses3.SORT_ICON_BUTTON,
  SORT_STATUS_LABEL: "." + cssClasses3.SORT_STATUS_LABEL
};
var messages = {
  SORTED_IN_DESCENDING: "Sorted in descending order",
  SORTED_IN_ASCENDING: "Sorted in ascending order"
};
var strings3 = {
  ARIA_SELECTED: attributes.ARIA_SELECTED,
  ARIA_SORT: attributes.ARIA_SORT,
  DATA_ROW_ID_ATTR: dataAttributes.ROW_ID,
  HEADER_ROW_CHECKBOX_SELECTOR: selectors.HEADER_ROW_CHECKBOX,
  ROW_CHECKBOX_SELECTOR: selectors.ROW_CHECKBOX,
  ROW_SELECTED_SELECTOR: selectors.ROW_SELECTED,
  ROW_SELECTOR: selectors.ROW
};
var SortValue;
(function(SortValue2) {
  SortValue2["ASCENDING"] = "ascending";
  SortValue2["DESCENDING"] = "descending";
  SortValue2["NONE"] = "none";
  SortValue2["OTHER"] = "other";
})(SortValue || (SortValue = {}));
var events = {
  ROW_CLICK: "MDCDataTable:rowClick",
  ROW_SELECTION_CHANGED: "MDCDataTable:rowSelectionChanged",
  SELECTED_ALL: "MDCDataTable:selectedAll",
  SORTED: "MDCDataTable:sorted",
  UNSELECTED_ALL: "MDCDataTable:unselectedAll"
};

// node_modules/@material/data-table/foundation.js
var MDCDataTableFoundation = function(_super) {
  __extends(MDCDataTableFoundation2, _super);
  function MDCDataTableFoundation2(adapter) {
    return _super.call(this, __assign(__assign({}, MDCDataTableFoundation2.defaultAdapter), adapter)) || this;
  }
  Object.defineProperty(MDCDataTableFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        addClassAtRowIndex: function() {
          return void 0;
        },
        getAttributeByHeaderCellIndex: function() {
          return "";
        },
        getHeaderCellCount: function() {
          return 0;
        },
        getHeaderCellElements: function() {
          return [];
        },
        getRowCount: function() {
          return 0;
        },
        getRowElements: function() {
          return [];
        },
        getRowIdAtIndex: function() {
          return "";
        },
        getRowIndexByChildElement: function() {
          return 0;
        },
        getSelectedRowCount: function() {
          return 0;
        },
        getTableContainerHeight: function() {
          return 0;
        },
        getTableHeaderHeight: function() {
          return 0;
        },
        isCheckboxAtRowIndexChecked: function() {
          return false;
        },
        isHeaderRowCheckboxChecked: function() {
          return false;
        },
        isRowsSelectable: function() {
          return false;
        },
        notifyRowSelectionChanged: function() {
          return void 0;
        },
        notifySelectedAll: function() {
          return void 0;
        },
        notifySortAction: function() {
          return void 0;
        },
        notifyUnselectedAll: function() {
          return void 0;
        },
        notifyRowClick: function() {
          return void 0;
        },
        registerHeaderRowCheckbox: function() {
          return void 0;
        },
        registerRowCheckboxes: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        removeClassAtRowIndex: function() {
          return void 0;
        },
        removeClassNameByHeaderCellIndex: function() {
          return void 0;
        },
        setAttributeAtRowIndex: function() {
          return void 0;
        },
        setAttributeByHeaderCellIndex: function() {
          return void 0;
        },
        setClassNameByHeaderCellIndex: function() {
          return void 0;
        },
        setHeaderRowCheckboxChecked: function() {
          return void 0;
        },
        setHeaderRowCheckboxIndeterminate: function() {
          return void 0;
        },
        setProgressIndicatorStyles: function() {
          return void 0;
        },
        setRowCheckboxCheckedAtIndex: function() {
          return void 0;
        },
        setSortStatusLabelByHeaderCellIndex: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCDataTableFoundation2.prototype.layout = function() {
    if (this.adapter.isRowsSelectable()) {
      this.adapter.registerHeaderRowCheckbox();
      this.adapter.registerRowCheckboxes();
      this.setHeaderRowCheckboxState();
    }
  };
  MDCDataTableFoundation2.prototype.layoutAsync = function() {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!this.adapter.isRowsSelectable())
              return [3, 3];
            return [4, this.adapter.registerHeaderRowCheckbox()];
          case 1:
            _a.sent();
            return [4, this.adapter.registerRowCheckboxes()];
          case 2:
            _a.sent();
            this.setHeaderRowCheckboxState();
            _a.label = 3;
          case 3:
            return [2];
        }
      });
    });
  };
  MDCDataTableFoundation2.prototype.getRows = function() {
    return this.adapter.getRowElements();
  };
  MDCDataTableFoundation2.prototype.getHeaderCells = function() {
    return this.adapter.getHeaderCellElements();
  };
  MDCDataTableFoundation2.prototype.setSelectedRowIds = function(rowIds) {
    for (var rowIndex = 0; rowIndex < this.adapter.getRowCount(); rowIndex++) {
      var rowId = this.adapter.getRowIdAtIndex(rowIndex);
      var isSelected = false;
      if (rowId && rowIds.indexOf(rowId) >= 0) {
        isSelected = true;
      }
      this.adapter.setRowCheckboxCheckedAtIndex(rowIndex, isSelected);
      this.selectRowAtIndex(rowIndex, isSelected);
    }
    this.setHeaderRowCheckboxState();
  };
  MDCDataTableFoundation2.prototype.getRowIds = function() {
    var rowIds = [];
    for (var rowIndex = 0; rowIndex < this.adapter.getRowCount(); rowIndex++) {
      rowIds.push(this.adapter.getRowIdAtIndex(rowIndex));
    }
    return rowIds;
  };
  MDCDataTableFoundation2.prototype.getSelectedRowIds = function() {
    var selectedRowIds = [];
    for (var rowIndex = 0; rowIndex < this.adapter.getRowCount(); rowIndex++) {
      if (this.adapter.isCheckboxAtRowIndexChecked(rowIndex)) {
        selectedRowIds.push(this.adapter.getRowIdAtIndex(rowIndex));
      }
    }
    return selectedRowIds;
  };
  MDCDataTableFoundation2.prototype.handleHeaderRowCheckboxChange = function() {
    var isHeaderChecked = this.adapter.isHeaderRowCheckboxChecked();
    for (var rowIndex = 0; rowIndex < this.adapter.getRowCount(); rowIndex++) {
      this.adapter.setRowCheckboxCheckedAtIndex(rowIndex, isHeaderChecked);
      this.selectRowAtIndex(rowIndex, isHeaderChecked);
    }
    if (isHeaderChecked) {
      this.adapter.notifySelectedAll();
    } else {
      this.adapter.notifyUnselectedAll();
    }
  };
  MDCDataTableFoundation2.prototype.handleRowCheckboxChange = function(event) {
    var rowIndex = this.adapter.getRowIndexByChildElement(event.target);
    if (rowIndex === -1) {
      return;
    }
    var selected = this.adapter.isCheckboxAtRowIndexChecked(rowIndex);
    this.selectRowAtIndex(rowIndex, selected);
    this.setHeaderRowCheckboxState();
    var rowId = this.adapter.getRowIdAtIndex(rowIndex);
    this.adapter.notifyRowSelectionChanged({ rowId, rowIndex, selected });
  };
  MDCDataTableFoundation2.prototype.handleSortAction = function(eventData) {
    var columnId = eventData.columnId, columnIndex = eventData.columnIndex, headerCell = eventData.headerCell;
    for (var index = 0; index < this.adapter.getHeaderCellCount(); index++) {
      if (index === columnIndex) {
        continue;
      }
      this.adapter.removeClassNameByHeaderCellIndex(index, cssClasses3.HEADER_CELL_SORTED);
      this.adapter.removeClassNameByHeaderCellIndex(index, cssClasses3.HEADER_CELL_SORTED_DESCENDING);
      this.adapter.setAttributeByHeaderCellIndex(index, strings3.ARIA_SORT, SortValue.NONE);
      this.adapter.setSortStatusLabelByHeaderCellIndex(index, SortValue.NONE);
    }
    this.adapter.setClassNameByHeaderCellIndex(columnIndex, cssClasses3.HEADER_CELL_SORTED);
    var currentSortValue = this.adapter.getAttributeByHeaderCellIndex(columnIndex, strings3.ARIA_SORT);
    var sortValue = SortValue.NONE;
    if (currentSortValue === SortValue.ASCENDING) {
      this.adapter.setClassNameByHeaderCellIndex(columnIndex, cssClasses3.HEADER_CELL_SORTED_DESCENDING);
      this.adapter.setAttributeByHeaderCellIndex(columnIndex, strings3.ARIA_SORT, SortValue.DESCENDING);
      sortValue = SortValue.DESCENDING;
    } else if (currentSortValue === SortValue.DESCENDING) {
      this.adapter.removeClassNameByHeaderCellIndex(columnIndex, cssClasses3.HEADER_CELL_SORTED_DESCENDING);
      this.adapter.setAttributeByHeaderCellIndex(columnIndex, strings3.ARIA_SORT, SortValue.ASCENDING);
      sortValue = SortValue.ASCENDING;
    } else {
      this.adapter.setAttributeByHeaderCellIndex(columnIndex, strings3.ARIA_SORT, SortValue.ASCENDING);
      sortValue = SortValue.ASCENDING;
    }
    this.adapter.setSortStatusLabelByHeaderCellIndex(columnIndex, sortValue);
    this.adapter.notifySortAction({
      columnId,
      columnIndex,
      headerCell,
      sortValue
    });
  };
  MDCDataTableFoundation2.prototype.handleRowClick = function(_a) {
    var rowId = _a.rowId, row = _a.row;
    this.adapter.notifyRowClick({
      rowId,
      row
    });
  };
  MDCDataTableFoundation2.prototype.showProgress = function() {
    var tableHeaderHeight = this.adapter.getTableHeaderHeight();
    var height = this.adapter.getTableContainerHeight() - tableHeaderHeight;
    var top = tableHeaderHeight;
    this.adapter.setProgressIndicatorStyles({
      height: height + "px",
      top: top + "px"
    });
    this.adapter.addClass(cssClasses3.IN_PROGRESS);
  };
  MDCDataTableFoundation2.prototype.hideProgress = function() {
    this.adapter.removeClass(cssClasses3.IN_PROGRESS);
  };
  MDCDataTableFoundation2.prototype.setHeaderRowCheckboxState = function() {
    if (this.adapter.getSelectedRowCount() === 0) {
      this.adapter.setHeaderRowCheckboxChecked(false);
      this.adapter.setHeaderRowCheckboxIndeterminate(false);
    } else if (this.adapter.getSelectedRowCount() === this.adapter.getRowCount()) {
      this.adapter.setHeaderRowCheckboxChecked(true);
      this.adapter.setHeaderRowCheckboxIndeterminate(false);
    } else {
      this.adapter.setHeaderRowCheckboxIndeterminate(true);
      this.adapter.setHeaderRowCheckboxChecked(false);
    }
  };
  MDCDataTableFoundation2.prototype.selectRowAtIndex = function(rowIndex, selected) {
    if (selected) {
      this.adapter.addClassAtRowIndex(rowIndex, cssClasses3.ROW_SELECTED);
      this.adapter.setAttributeAtRowIndex(rowIndex, strings3.ARIA_SELECTED, "true");
    } else {
      this.adapter.removeClassAtRowIndex(rowIndex, cssClasses3.ROW_SELECTED);
      this.adapter.setAttributeAtRowIndex(rowIndex, strings3.ARIA_SELECTED, "false");
    }
  };
  return MDCDataTableFoundation2;
}(MDCFoundation);

// node_modules/@material/data-table/component.js
var MDCDataTable = function(_super) {
  __extends(MDCDataTable2, _super);
  function MDCDataTable2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCDataTable2.attachTo = function(root) {
    return new MDCDataTable2(root);
  };
  MDCDataTable2.prototype.initialize = function(checkboxFactory) {
    if (checkboxFactory === void 0) {
      checkboxFactory = function(el) {
        return new MDCCheckbox(el);
      };
    }
    this.checkboxFactory = checkboxFactory;
  };
  MDCDataTable2.prototype.initialSyncWithDOM = function() {
    var _this = this;
    this.headerRow = this.root.querySelector("." + cssClasses3.HEADER_ROW);
    this.handleHeaderRowCheckboxChange = function() {
      _this.foundation.handleHeaderRowCheckboxChange();
    };
    this.headerRow.addEventListener("change", this.handleHeaderRowCheckboxChange);
    this.headerRowClickListener = function(event) {
      _this.handleHeaderRowClick(event);
    };
    this.headerRow.addEventListener("click", this.headerRowClickListener);
    this.content = this.root.querySelector("." + cssClasses3.CONTENT);
    this.handleContentClick = function(event) {
      var dataRowEl = closest(event.target, selectors.ROW);
      if (!dataRowEl)
        return;
      _this.foundation.handleRowClick({
        rowId: _this.getRowIdByRowElement(dataRowEl),
        row: dataRowEl
      });
    };
    this.content.addEventListener("click", this.handleContentClick);
    this.handleRowCheckboxChange = function(event) {
      _this.foundation.handleRowCheckboxChange(event);
    };
    this.content.addEventListener("change", this.handleRowCheckboxChange);
    this.layout();
  };
  MDCDataTable2.prototype.layout = function() {
    this.foundation.layout();
  };
  MDCDataTable2.prototype.getHeaderCells = function() {
    return [].slice.call(this.root.querySelectorAll(selectors.HEADER_CELL));
  };
  MDCDataTable2.prototype.getRows = function() {
    return this.foundation.getRows();
  };
  MDCDataTable2.prototype.getSelectedRowIds = function() {
    return this.foundation.getSelectedRowIds();
  };
  MDCDataTable2.prototype.setSelectedRowIds = function(rowIds) {
    this.foundation.setSelectedRowIds(rowIds);
  };
  MDCDataTable2.prototype.showProgress = function() {
    this.getLinearProgress().open();
    this.foundation.showProgress();
  };
  MDCDataTable2.prototype.hideProgress = function() {
    this.foundation.hideProgress();
    this.getLinearProgress().close();
  };
  MDCDataTable2.prototype.destroy = function() {
    var e_1, _a;
    if (this.handleHeaderRowCheckboxChange) {
      this.headerRow.removeEventListener("change", this.handleHeaderRowCheckboxChange);
    }
    if (this.headerRowClickListener) {
      this.headerRow.removeEventListener("click", this.headerRowClickListener);
    }
    if (this.handleRowCheckboxChange) {
      this.content.removeEventListener("change", this.handleRowCheckboxChange);
    }
    if (this.headerRowCheckbox) {
      this.headerRowCheckbox.destroy();
    }
    if (this.rowCheckboxList) {
      try {
        for (var _b = __values(this.rowCheckboxList), _c = _b.next(); !_c.done; _c = _b.next()) {
          var checkbox = _c.value;
          checkbox.destroy();
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }
    if (this.handleContentClick) {
      this.content.removeEventListener("click", this.handleContentClick);
    }
  };
  MDCDataTable2.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      addClass: function(className) {
        _this.root.classList.add(className);
      },
      removeClass: function(className) {
        _this.root.classList.remove(className);
      },
      getHeaderCellElements: function() {
        return _this.getHeaderCells();
      },
      getHeaderCellCount: function() {
        return _this.getHeaderCells().length;
      },
      getAttributeByHeaderCellIndex: function(index, attribute) {
        return _this.getHeaderCells()[index].getAttribute(attribute);
      },
      setAttributeByHeaderCellIndex: function(index, attribute, value) {
        _this.getHeaderCells()[index].setAttribute(attribute, value);
      },
      setClassNameByHeaderCellIndex: function(index, className) {
        _this.getHeaderCells()[index].classList.add(className);
      },
      removeClassNameByHeaderCellIndex: function(index, className) {
        _this.getHeaderCells()[index].classList.remove(className);
      },
      notifySortAction: function(data) {
        _this.emit(events.SORTED, data, true);
      },
      getTableContainerHeight: function() {
        var tableContainer = _this.root.querySelector("." + cssClasses3.TABLE_CONTAINER);
        if (!tableContainer) {
          throw new Error("MDCDataTable: Table container element not found.");
        }
        return tableContainer.getBoundingClientRect().height;
      },
      getTableHeaderHeight: function() {
        var tableHeader = _this.root.querySelector(selectors.HEADER_ROW);
        if (!tableHeader) {
          throw new Error("MDCDataTable: Table header element not found.");
        }
        return tableHeader.getBoundingClientRect().height;
      },
      setProgressIndicatorStyles: function(styles) {
        var progressIndicator = _this.root.querySelector(selectors.PROGRESS_INDICATOR);
        if (!progressIndicator) {
          throw new Error("MDCDataTable: Progress indicator element not found.");
        }
        progressIndicator.style.setProperty("height", styles.height);
        progressIndicator.style.setProperty("top", styles.top);
      },
      addClassAtRowIndex: function(rowIndex, className) {
        _this.getRows()[rowIndex].classList.add(className);
      },
      getRowCount: function() {
        return _this.getRows().length;
      },
      getRowElements: function() {
        return [].slice.call(_this.root.querySelectorAll(selectors.ROW));
      },
      getRowIdAtIndex: function(rowIndex) {
        return _this.getRows()[rowIndex].getAttribute(dataAttributes.ROW_ID);
      },
      getRowIndexByChildElement: function(el) {
        return _this.getRows().indexOf(closest(el, selectors.ROW));
      },
      getSelectedRowCount: function() {
        return _this.root.querySelectorAll(selectors.ROW_SELECTED).length;
      },
      isCheckboxAtRowIndexChecked: function(rowIndex) {
        return _this.rowCheckboxList[rowIndex].checked;
      },
      isHeaderRowCheckboxChecked: function() {
        return _this.headerRowCheckbox.checked;
      },
      isRowsSelectable: function() {
        return !!_this.root.querySelector(selectors.ROW_CHECKBOX) || !!_this.root.querySelector(selectors.HEADER_ROW_CHECKBOX);
      },
      notifyRowSelectionChanged: function(data) {
        _this.emit(events.ROW_SELECTION_CHANGED, {
          row: _this.getRowByIndex(data.rowIndex),
          rowId: _this.getRowIdByIndex(data.rowIndex),
          rowIndex: data.rowIndex,
          selected: data.selected
        }, true);
      },
      notifySelectedAll: function() {
        _this.emit(events.SELECTED_ALL, {}, true);
      },
      notifyUnselectedAll: function() {
        _this.emit(events.UNSELECTED_ALL, {}, true);
      },
      notifyRowClick: function(data) {
        _this.emit(events.ROW_CLICK, data, true);
      },
      registerHeaderRowCheckbox: function() {
        if (_this.headerRowCheckbox) {
          _this.headerRowCheckbox.destroy();
        }
        var checkboxEl = _this.root.querySelector(selectors.HEADER_ROW_CHECKBOX);
        _this.headerRowCheckbox = _this.checkboxFactory(checkboxEl);
      },
      registerRowCheckboxes: function() {
        if (_this.rowCheckboxList) {
          _this.rowCheckboxList.forEach(function(checkbox) {
            checkbox.destroy();
          });
        }
        _this.rowCheckboxList = [];
        _this.getRows().forEach(function(rowEl) {
          var checkbox = _this.checkboxFactory(rowEl.querySelector(selectors.ROW_CHECKBOX));
          _this.rowCheckboxList.push(checkbox);
        });
      },
      removeClassAtRowIndex: function(rowIndex, className) {
        _this.getRows()[rowIndex].classList.remove(className);
      },
      setAttributeAtRowIndex: function(rowIndex, attr, value) {
        _this.getRows()[rowIndex].setAttribute(attr, value);
      },
      setHeaderRowCheckboxChecked: function(checked) {
        _this.headerRowCheckbox.checked = checked;
      },
      setHeaderRowCheckboxIndeterminate: function(indeterminate) {
        _this.headerRowCheckbox.indeterminate = indeterminate;
      },
      setRowCheckboxCheckedAtIndex: function(rowIndex, checked) {
        _this.rowCheckboxList[rowIndex].checked = checked;
      },
      setSortStatusLabelByHeaderCellIndex: function(columnIndex, sortValue) {
        var headerCell = _this.getHeaderCells()[columnIndex];
        var sortStatusLabel = headerCell.querySelector(selectors.SORT_STATUS_LABEL);
        if (!sortStatusLabel)
          return;
        sortStatusLabel.textContent = _this.getSortStatusMessageBySortValue(sortValue);
      }
    };
    return new MDCDataTableFoundation(adapter);
  };
  MDCDataTable2.prototype.getRowByIndex = function(index) {
    return this.getRows()[index];
  };
  MDCDataTable2.prototype.getRowIdByIndex = function(index) {
    return this.getRowByIndex(index).getAttribute(dataAttributes.ROW_ID);
  };
  MDCDataTable2.prototype.handleHeaderRowClick = function(event) {
    var headerCell = closest(event.target, selectors.HEADER_CELL_WITH_SORT);
    if (!headerCell) {
      return;
    }
    var columnId = headerCell.getAttribute(dataAttributes.COLUMN_ID);
    var columnIndex = this.getHeaderCells().indexOf(headerCell);
    if (columnIndex === -1) {
      return;
    }
    this.foundation.handleSortAction({ columnId, columnIndex, headerCell });
  };
  MDCDataTable2.prototype.getSortStatusMessageBySortValue = function(sortValue) {
    switch (sortValue) {
      case SortValue.ASCENDING:
        return messages.SORTED_IN_ASCENDING;
      case SortValue.DESCENDING:
        return messages.SORTED_IN_DESCENDING;
      default:
        return "";
    }
  };
  MDCDataTable2.prototype.getLinearProgressElement = function() {
    var el = this.root.querySelector("." + cssClasses3.LINEAR_PROGRESS);
    if (!el) {
      throw new Error("MDCDataTable: linear progress element is not found.");
    }
    return el;
  };
  MDCDataTable2.prototype.getLinearProgress = function() {
    if (!this.linearProgress) {
      var el = this.getLinearProgressElement();
      this.linearProgress = new MDCLinearProgress(el);
    }
    return this.linearProgress;
  };
  MDCDataTable2.prototype.getRowIdByRowElement = function(rowElement) {
    return rowElement.getAttribute(dataAttributes.ROW_ID);
  };
  return MDCDataTable2;
}(MDCComponent);
export {
  MDCDataTable,
  MDCDataTableFoundation,
  SortValue,
  attributes,
  cssClasses3 as cssClasses,
  dataAttributes,
  events,
  messages,
  selectors,
  strings3 as strings
};
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
//# sourceMappingURL=@material_data-table.js.map
