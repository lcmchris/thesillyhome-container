import {
  MDCTab,
  MDCTabFoundation
} from "./chunk-A3DTIEVV.js";
import "./chunk-E3K7WDLC.js";
import {
  MDCTabScroller
} from "./chunk-TRY7GIZQ.js";
import "./chunk-2QYY3AJL.js";
import "./chunk-6DZTNVPL.js";
import "./chunk-PWEMLQJ7.js";
import {
  MDCComponent,
  MDCFoundation,
  __assign,
  __extends,
  __values
} from "./chunk-2UTNIWRO.js";
import "./chunk-JC4IRQUL.js";

// node_modules/@material/tab-bar/constants.js
var strings = {
  ARROW_LEFT_KEY: "ArrowLeft",
  ARROW_RIGHT_KEY: "ArrowRight",
  END_KEY: "End",
  ENTER_KEY: "Enter",
  HOME_KEY: "Home",
  SPACE_KEY: "Space",
  TAB_ACTIVATED_EVENT: "MDCTabBar:activated",
  TAB_SCROLLER_SELECTOR: ".mdc-tab-scroller",
  TAB_SELECTOR: ".mdc-tab"
};
var numbers = {
  ARROW_LEFT_KEYCODE: 37,
  ARROW_RIGHT_KEYCODE: 39,
  END_KEYCODE: 35,
  ENTER_KEYCODE: 13,
  EXTRA_SCROLL_AMOUNT: 20,
  HOME_KEYCODE: 36,
  SPACE_KEYCODE: 32
};

// node_modules/@material/tab-bar/foundation.js
var ACCEPTABLE_KEYS = /* @__PURE__ */ new Set();
ACCEPTABLE_KEYS.add(strings.ARROW_LEFT_KEY);
ACCEPTABLE_KEYS.add(strings.ARROW_RIGHT_KEY);
ACCEPTABLE_KEYS.add(strings.END_KEY);
ACCEPTABLE_KEYS.add(strings.HOME_KEY);
ACCEPTABLE_KEYS.add(strings.ENTER_KEY);
ACCEPTABLE_KEYS.add(strings.SPACE_KEY);
var KEYCODE_MAP = /* @__PURE__ */ new Map();
KEYCODE_MAP.set(numbers.ARROW_LEFT_KEYCODE, strings.ARROW_LEFT_KEY);
KEYCODE_MAP.set(numbers.ARROW_RIGHT_KEYCODE, strings.ARROW_RIGHT_KEY);
KEYCODE_MAP.set(numbers.END_KEYCODE, strings.END_KEY);
KEYCODE_MAP.set(numbers.HOME_KEYCODE, strings.HOME_KEY);
KEYCODE_MAP.set(numbers.ENTER_KEYCODE, strings.ENTER_KEY);
KEYCODE_MAP.set(numbers.SPACE_KEYCODE, strings.SPACE_KEY);
var MDCTabBarFoundation = function(_super) {
  __extends(MDCTabBarFoundation2, _super);
  function MDCTabBarFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCTabBarFoundation2.defaultAdapter), adapter)) || this;
    _this.useAutomaticActivation = false;
    return _this;
  }
  Object.defineProperty(MDCTabBarFoundation2, "strings", {
    get: function() {
      return strings;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTabBarFoundation2, "numbers", {
    get: function() {
      return numbers;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTabBarFoundation2, "defaultAdapter", {
    get: function() {
      return {
        scrollTo: function() {
          return void 0;
        },
        incrementScroll: function() {
          return void 0;
        },
        getScrollPosition: function() {
          return 0;
        },
        getScrollContentWidth: function() {
          return 0;
        },
        getOffsetWidth: function() {
          return 0;
        },
        isRTL: function() {
          return false;
        },
        setActiveTab: function() {
          return void 0;
        },
        activateTabAtIndex: function() {
          return void 0;
        },
        deactivateTabAtIndex: function() {
          return void 0;
        },
        focusTabAtIndex: function() {
          return void 0;
        },
        getTabIndicatorClientRectAtIndex: function() {
          return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
        },
        getTabDimensionsAtIndex: function() {
          return { rootLeft: 0, rootRight: 0, contentLeft: 0, contentRight: 0 };
        },
        getPreviousActiveTabIndex: function() {
          return -1;
        },
        getFocusedTabIndex: function() {
          return -1;
        },
        getIndexOfTabById: function() {
          return -1;
        },
        getTabListLength: function() {
          return 0;
        },
        notifyTabActivated: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCTabBarFoundation2.prototype.setUseAutomaticActivation = function(useAutomaticActivation) {
    this.useAutomaticActivation = useAutomaticActivation;
  };
  MDCTabBarFoundation2.prototype.activateTab = function(index) {
    var previousActiveIndex = this.adapter.getPreviousActiveTabIndex();
    if (!this.indexIsInRange(index) || index === previousActiveIndex) {
      return;
    }
    var previousClientRect;
    if (previousActiveIndex !== -1) {
      this.adapter.deactivateTabAtIndex(previousActiveIndex);
      previousClientRect = this.adapter.getTabIndicatorClientRectAtIndex(previousActiveIndex);
    }
    this.adapter.activateTabAtIndex(index, previousClientRect);
    this.scrollIntoView(index);
    this.adapter.notifyTabActivated(index);
  };
  MDCTabBarFoundation2.prototype.handleKeyDown = function(evt) {
    var key = this.getKeyFromEvent(evt);
    if (key === void 0) {
      return;
    }
    if (!this.isActivationKey(key)) {
      evt.preventDefault();
    }
    if (this.useAutomaticActivation) {
      if (this.isActivationKey(key)) {
        return;
      }
      var index = this.determineTargetFromKey(this.adapter.getPreviousActiveTabIndex(), key);
      this.adapter.setActiveTab(index);
      this.scrollIntoView(index);
    } else {
      var focusedTabIndex = this.adapter.getFocusedTabIndex();
      if (this.isActivationKey(key)) {
        this.adapter.setActiveTab(focusedTabIndex);
      } else {
        var index = this.determineTargetFromKey(focusedTabIndex, key);
        this.adapter.focusTabAtIndex(index);
        this.scrollIntoView(index);
      }
    }
  };
  MDCTabBarFoundation2.prototype.handleTabInteraction = function(evt) {
    this.adapter.setActiveTab(this.adapter.getIndexOfTabById(evt.detail.tabId));
  };
  MDCTabBarFoundation2.prototype.scrollIntoView = function(index) {
    if (!this.indexIsInRange(index)) {
      return;
    }
    if (index === 0) {
      this.adapter.scrollTo(0);
      return;
    }
    if (index === this.adapter.getTabListLength() - 1) {
      this.adapter.scrollTo(this.adapter.getScrollContentWidth());
      return;
    }
    if (this.isRTL()) {
      this.scrollIntoViewImplRTL(index);
      return;
    }
    this.scrollIntoViewImpl(index);
  };
  MDCTabBarFoundation2.prototype.determineTargetFromKey = function(origin, key) {
    var isRTL = this.isRTL();
    var maxIndex = this.adapter.getTabListLength() - 1;
    var shouldGoToEnd = key === strings.END_KEY;
    var shouldDecrement = key === strings.ARROW_LEFT_KEY && !isRTL || key === strings.ARROW_RIGHT_KEY && isRTL;
    var shouldIncrement = key === strings.ARROW_RIGHT_KEY && !isRTL || key === strings.ARROW_LEFT_KEY && isRTL;
    var index = origin;
    if (shouldGoToEnd) {
      index = maxIndex;
    } else if (shouldDecrement) {
      index -= 1;
    } else if (shouldIncrement) {
      index += 1;
    } else {
      index = 0;
    }
    if (index < 0) {
      index = maxIndex;
    } else if (index > maxIndex) {
      index = 0;
    }
    return index;
  };
  MDCTabBarFoundation2.prototype.calculateScrollIncrement = function(index, nextIndex, scrollPosition, barWidth) {
    var nextTabDimensions = this.adapter.getTabDimensionsAtIndex(nextIndex);
    var relativeContentLeft = nextTabDimensions.contentLeft - scrollPosition - barWidth;
    var relativeContentRight = nextTabDimensions.contentRight - scrollPosition;
    var leftIncrement = relativeContentRight - numbers.EXTRA_SCROLL_AMOUNT;
    var rightIncrement = relativeContentLeft + numbers.EXTRA_SCROLL_AMOUNT;
    if (nextIndex < index) {
      return Math.min(leftIncrement, 0);
    }
    return Math.max(rightIncrement, 0);
  };
  MDCTabBarFoundation2.prototype.calculateScrollIncrementRTL = function(index, nextIndex, scrollPosition, barWidth, scrollContentWidth) {
    var nextTabDimensions = this.adapter.getTabDimensionsAtIndex(nextIndex);
    var relativeContentLeft = scrollContentWidth - nextTabDimensions.contentLeft - scrollPosition;
    var relativeContentRight = scrollContentWidth - nextTabDimensions.contentRight - scrollPosition - barWidth;
    var leftIncrement = relativeContentRight + numbers.EXTRA_SCROLL_AMOUNT;
    var rightIncrement = relativeContentLeft - numbers.EXTRA_SCROLL_AMOUNT;
    if (nextIndex > index) {
      return Math.max(leftIncrement, 0);
    }
    return Math.min(rightIncrement, 0);
  };
  MDCTabBarFoundation2.prototype.findAdjacentTabIndexClosestToEdge = function(index, tabDimensions, scrollPosition, barWidth) {
    var relativeRootLeft = tabDimensions.rootLeft - scrollPosition;
    var relativeRootRight = tabDimensions.rootRight - scrollPosition - barWidth;
    var relativeRootDelta = relativeRootLeft + relativeRootRight;
    var leftEdgeIsCloser = relativeRootLeft < 0 || relativeRootDelta < 0;
    var rightEdgeIsCloser = relativeRootRight > 0 || relativeRootDelta > 0;
    if (leftEdgeIsCloser) {
      return index - 1;
    }
    if (rightEdgeIsCloser) {
      return index + 1;
    }
    return -1;
  };
  MDCTabBarFoundation2.prototype.findAdjacentTabIndexClosestToEdgeRTL = function(index, tabDimensions, scrollPosition, barWidth, scrollContentWidth) {
    var rootLeft = scrollContentWidth - tabDimensions.rootLeft - barWidth - scrollPosition;
    var rootRight = scrollContentWidth - tabDimensions.rootRight - scrollPosition;
    var rootDelta = rootLeft + rootRight;
    var leftEdgeIsCloser = rootLeft > 0 || rootDelta > 0;
    var rightEdgeIsCloser = rootRight < 0 || rootDelta < 0;
    if (leftEdgeIsCloser) {
      return index + 1;
    }
    if (rightEdgeIsCloser) {
      return index - 1;
    }
    return -1;
  };
  MDCTabBarFoundation2.prototype.getKeyFromEvent = function(evt) {
    if (ACCEPTABLE_KEYS.has(evt.key)) {
      return evt.key;
    }
    return KEYCODE_MAP.get(evt.keyCode);
  };
  MDCTabBarFoundation2.prototype.isActivationKey = function(key) {
    return key === strings.SPACE_KEY || key === strings.ENTER_KEY;
  };
  MDCTabBarFoundation2.prototype.indexIsInRange = function(index) {
    return index >= 0 && index < this.adapter.getTabListLength();
  };
  MDCTabBarFoundation2.prototype.isRTL = function() {
    return this.adapter.isRTL();
  };
  MDCTabBarFoundation2.prototype.scrollIntoViewImpl = function(index) {
    var scrollPosition = this.adapter.getScrollPosition();
    var barWidth = this.adapter.getOffsetWidth();
    var tabDimensions = this.adapter.getTabDimensionsAtIndex(index);
    var nextIndex = this.findAdjacentTabIndexClosestToEdge(index, tabDimensions, scrollPosition, barWidth);
    if (!this.indexIsInRange(nextIndex)) {
      return;
    }
    var scrollIncrement = this.calculateScrollIncrement(index, nextIndex, scrollPosition, barWidth);
    this.adapter.incrementScroll(scrollIncrement);
  };
  MDCTabBarFoundation2.prototype.scrollIntoViewImplRTL = function(index) {
    var scrollPosition = this.adapter.getScrollPosition();
    var barWidth = this.adapter.getOffsetWidth();
    var tabDimensions = this.adapter.getTabDimensionsAtIndex(index);
    var scrollWidth = this.adapter.getScrollContentWidth();
    var nextIndex = this.findAdjacentTabIndexClosestToEdgeRTL(index, tabDimensions, scrollPosition, barWidth, scrollWidth);
    if (!this.indexIsInRange(nextIndex)) {
      return;
    }
    var scrollIncrement = this.calculateScrollIncrementRTL(index, nextIndex, scrollPosition, barWidth, scrollWidth);
    this.adapter.incrementScroll(scrollIncrement);
  };
  return MDCTabBarFoundation2;
}(MDCFoundation);

// node_modules/@material/tab-bar/component.js
var strings2 = MDCTabBarFoundation.strings;
var tabIdCounter = 0;
var MDCTabBar = function(_super) {
  __extends(MDCTabBar2, _super);
  function MDCTabBar2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCTabBar2.attachTo = function(root) {
    return new MDCTabBar2(root);
  };
  Object.defineProperty(MDCTabBar2.prototype, "focusOnActivate", {
    set: function(focusOnActivate) {
      var e_1, _a;
      try {
        for (var _b = __values(this.tabList), _c = _b.next(); !_c.done; _c = _b.next()) {
          var tab = _c.value;
          tab.focusOnActivate = focusOnActivate;
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTabBar2.prototype, "useAutomaticActivation", {
    set: function(useAutomaticActivation) {
      this.foundation.setUseAutomaticActivation(useAutomaticActivation);
    },
    enumerable: false,
    configurable: true
  });
  MDCTabBar2.prototype.initialize = function(tabFactory, tabScrollerFactory) {
    if (tabFactory === void 0) {
      tabFactory = function(el) {
        return new MDCTab(el);
      };
    }
    if (tabScrollerFactory === void 0) {
      tabScrollerFactory = function(el) {
        return new MDCTabScroller(el);
      };
    }
    this.tabList = this.instantiateTabs(tabFactory);
    this.tabScroller = this.instantiatetabScroller(tabScrollerFactory);
  };
  MDCTabBar2.prototype.initialSyncWithDOM = function() {
    var _this = this;
    this.handleTabInteraction = function(evt) {
      _this.foundation.handleTabInteraction(evt);
    };
    this.handleKeyDown = function(evt) {
      _this.foundation.handleKeyDown(evt);
    };
    this.listen(MDCTabFoundation.strings.INTERACTED_EVENT, this.handleTabInteraction);
    this.listen("keydown", this.handleKeyDown);
    for (var i = 0; i < this.tabList.length; i++) {
      if (this.tabList[i].active) {
        this.scrollIntoView(i);
        break;
      }
    }
  };
  MDCTabBar2.prototype.destroy = function() {
    var e_2, _a;
    _super.prototype.destroy.call(this);
    this.unlisten(MDCTabFoundation.strings.INTERACTED_EVENT, this.handleTabInteraction);
    this.unlisten("keydown", this.handleKeyDown);
    try {
      for (var _b = __values(this.tabList), _c = _b.next(); !_c.done; _c = _b.next()) {
        var tab = _c.value;
        tab.destroy();
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    if (this.tabScroller) {
      this.tabScroller.destroy();
    }
  };
  MDCTabBar2.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      scrollTo: function(scrollX) {
        _this.tabScroller.scrollTo(scrollX);
      },
      incrementScroll: function(scrollXIncrement) {
        _this.tabScroller.incrementScroll(scrollXIncrement);
      },
      getScrollPosition: function() {
        return _this.tabScroller.getScrollPosition();
      },
      getScrollContentWidth: function() {
        return _this.tabScroller.getScrollContentWidth();
      },
      getOffsetWidth: function() {
        return _this.root.offsetWidth;
      },
      isRTL: function() {
        return window.getComputedStyle(_this.root).getPropertyValue("direction") === "rtl";
      },
      setActiveTab: function(index) {
        _this.foundation.activateTab(index);
      },
      activateTabAtIndex: function(index, clientRect) {
        _this.tabList[index].activate(clientRect);
      },
      deactivateTabAtIndex: function(index) {
        _this.tabList[index].deactivate();
      },
      focusTabAtIndex: function(index) {
        _this.tabList[index].focus();
      },
      getTabIndicatorClientRectAtIndex: function(index) {
        return _this.tabList[index].computeIndicatorClientRect();
      },
      getTabDimensionsAtIndex: function(index) {
        return _this.tabList[index].computeDimensions();
      },
      getPreviousActiveTabIndex: function() {
        for (var i = 0; i < _this.tabList.length; i++) {
          if (_this.tabList[i].active) {
            return i;
          }
        }
        return -1;
      },
      getFocusedTabIndex: function() {
        var tabElements = _this.getTabElements();
        var activeElement = document.activeElement;
        return tabElements.indexOf(activeElement);
      },
      getIndexOfTabById: function(id) {
        for (var i = 0; i < _this.tabList.length; i++) {
          if (_this.tabList[i].id === id) {
            return i;
          }
        }
        return -1;
      },
      getTabListLength: function() {
        return _this.tabList.length;
      },
      notifyTabActivated: function(index) {
        return _this.emit(strings2.TAB_ACTIVATED_EVENT, { index }, true);
      }
    };
    return new MDCTabBarFoundation(adapter);
  };
  MDCTabBar2.prototype.activateTab = function(index) {
    this.foundation.activateTab(index);
  };
  MDCTabBar2.prototype.scrollIntoView = function(index) {
    this.foundation.scrollIntoView(index);
  };
  MDCTabBar2.prototype.getTabElements = function() {
    return [].slice.call(this.root.querySelectorAll(strings2.TAB_SELECTOR));
  };
  MDCTabBar2.prototype.instantiateTabs = function(tabFactory) {
    return this.getTabElements().map(function(el) {
      el.id = el.id || "mdc-tab-" + ++tabIdCounter;
      return tabFactory(el);
    });
  };
  MDCTabBar2.prototype.instantiatetabScroller = function(tabScrollerFactory) {
    var tabScrollerElement = this.root.querySelector(strings2.TAB_SCROLLER_SELECTOR);
    if (tabScrollerElement) {
      return tabScrollerFactory(tabScrollerElement);
    }
    return null;
  };
  return MDCTabBar2;
}(MDCComponent);
export {
  MDCTabBar,
  MDCTabBarFoundation,
  numbers,
  strings
};
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
//# sourceMappingURL=@material_tab-bar.js.map
