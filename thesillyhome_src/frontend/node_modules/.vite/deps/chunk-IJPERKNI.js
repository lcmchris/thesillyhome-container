import {
  applyPassive
} from "./chunk-2QYY3AJL.js";
import {
  matches
} from "./chunk-PWEMLQJ7.js";
import {
  MDCComponent,
  MDCFoundation,
  __assign,
  __extends,
  __read
} from "./chunk-QFMKUBZP.js";
import {
  __export
} from "./chunk-JC4IRQUL.js";

// node_modules/@material/tab-scroller/constants.js
var cssClasses = {
  ANIMATING: "mdc-tab-scroller--animating",
  SCROLL_AREA_SCROLL: "mdc-tab-scroller__scroll-area--scroll",
  SCROLL_TEST: "mdc-tab-scroller__test"
};
var strings = {
  AREA_SELECTOR: ".mdc-tab-scroller__scroll-area",
  CONTENT_SELECTOR: ".mdc-tab-scroller__scroll-content"
};

// node_modules/@material/tab-scroller/rtl-scroller.js
var MDCTabScrollerRTL = function() {
  function MDCTabScrollerRTL2(adapter) {
    this.adapter = adapter;
  }
  return MDCTabScrollerRTL2;
}();

// node_modules/@material/tab-scroller/rtl-default-scroller.js
var MDCTabScrollerRTLDefault = function(_super) {
  __extends(MDCTabScrollerRTLDefault2, _super);
  function MDCTabScrollerRTLDefault2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCTabScrollerRTLDefault2.prototype.getScrollPositionRTL = function() {
    var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
    var right = this.calculateScrollEdges().right;
    return Math.round(right - currentScrollLeft);
  };
  MDCTabScrollerRTLDefault2.prototype.scrollToRTL = function(scrollX) {
    var edges = this.calculateScrollEdges();
    var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
    var clampedScrollLeft = this.clampScrollValue(edges.right - scrollX);
    return {
      finalScrollPosition: clampedScrollLeft,
      scrollDelta: clampedScrollLeft - currentScrollLeft
    };
  };
  MDCTabScrollerRTLDefault2.prototype.incrementScrollRTL = function(scrollX) {
    var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
    var clampedScrollLeft = this.clampScrollValue(currentScrollLeft - scrollX);
    return {
      finalScrollPosition: clampedScrollLeft,
      scrollDelta: clampedScrollLeft - currentScrollLeft
    };
  };
  MDCTabScrollerRTLDefault2.prototype.getAnimatingScrollPosition = function(scrollX) {
    return scrollX;
  };
  MDCTabScrollerRTLDefault2.prototype.calculateScrollEdges = function() {
    var contentWidth = this.adapter.getScrollContentOffsetWidth();
    var rootWidth = this.adapter.getScrollAreaOffsetWidth();
    return {
      left: 0,
      right: contentWidth - rootWidth
    };
  };
  MDCTabScrollerRTLDefault2.prototype.clampScrollValue = function(scrollX) {
    var edges = this.calculateScrollEdges();
    return Math.min(Math.max(edges.left, scrollX), edges.right);
  };
  return MDCTabScrollerRTLDefault2;
}(MDCTabScrollerRTL);

// node_modules/@material/tab-scroller/rtl-negative-scroller.js
var MDCTabScrollerRTLNegative = function(_super) {
  __extends(MDCTabScrollerRTLNegative2, _super);
  function MDCTabScrollerRTLNegative2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCTabScrollerRTLNegative2.prototype.getScrollPositionRTL = function(translateX) {
    var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
    return Math.round(translateX - currentScrollLeft);
  };
  MDCTabScrollerRTLNegative2.prototype.scrollToRTL = function(scrollX) {
    var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
    var clampedScrollLeft = this.clampScrollValue(-scrollX);
    return {
      finalScrollPosition: clampedScrollLeft,
      scrollDelta: clampedScrollLeft - currentScrollLeft
    };
  };
  MDCTabScrollerRTLNegative2.prototype.incrementScrollRTL = function(scrollX) {
    var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
    var clampedScrollLeft = this.clampScrollValue(currentScrollLeft - scrollX);
    return {
      finalScrollPosition: clampedScrollLeft,
      scrollDelta: clampedScrollLeft - currentScrollLeft
    };
  };
  MDCTabScrollerRTLNegative2.prototype.getAnimatingScrollPosition = function(scrollX, translateX) {
    return scrollX - translateX;
  };
  MDCTabScrollerRTLNegative2.prototype.calculateScrollEdges = function() {
    var contentWidth = this.adapter.getScrollContentOffsetWidth();
    var rootWidth = this.adapter.getScrollAreaOffsetWidth();
    return {
      left: rootWidth - contentWidth,
      right: 0
    };
  };
  MDCTabScrollerRTLNegative2.prototype.clampScrollValue = function(scrollX) {
    var edges = this.calculateScrollEdges();
    return Math.max(Math.min(edges.right, scrollX), edges.left);
  };
  return MDCTabScrollerRTLNegative2;
}(MDCTabScrollerRTL);

// node_modules/@material/tab-scroller/rtl-reverse-scroller.js
var MDCTabScrollerRTLReverse = function(_super) {
  __extends(MDCTabScrollerRTLReverse2, _super);
  function MDCTabScrollerRTLReverse2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCTabScrollerRTLReverse2.prototype.getScrollPositionRTL = function(translateX) {
    var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
    return Math.round(currentScrollLeft - translateX);
  };
  MDCTabScrollerRTLReverse2.prototype.scrollToRTL = function(scrollX) {
    var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
    var clampedScrollLeft = this.clampScrollValue(scrollX);
    return {
      finalScrollPosition: clampedScrollLeft,
      scrollDelta: currentScrollLeft - clampedScrollLeft
    };
  };
  MDCTabScrollerRTLReverse2.prototype.incrementScrollRTL = function(scrollX) {
    var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
    var clampedScrollLeft = this.clampScrollValue(currentScrollLeft + scrollX);
    return {
      finalScrollPosition: clampedScrollLeft,
      scrollDelta: currentScrollLeft - clampedScrollLeft
    };
  };
  MDCTabScrollerRTLReverse2.prototype.getAnimatingScrollPosition = function(scrollX, translateX) {
    return scrollX + translateX;
  };
  MDCTabScrollerRTLReverse2.prototype.calculateScrollEdges = function() {
    var contentWidth = this.adapter.getScrollContentOffsetWidth();
    var rootWidth = this.adapter.getScrollAreaOffsetWidth();
    return {
      left: contentWidth - rootWidth,
      right: 0
    };
  };
  MDCTabScrollerRTLReverse2.prototype.clampScrollValue = function(scrollX) {
    var edges = this.calculateScrollEdges();
    return Math.min(Math.max(edges.right, scrollX), edges.left);
  };
  return MDCTabScrollerRTLReverse2;
}(MDCTabScrollerRTL);

// node_modules/@material/tab-scroller/foundation.js
var MDCTabScrollerFoundation = function(_super) {
  __extends(MDCTabScrollerFoundation2, _super);
  function MDCTabScrollerFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCTabScrollerFoundation2.defaultAdapter), adapter)) || this;
    _this.isAnimating = false;
    return _this;
  }
  Object.defineProperty(MDCTabScrollerFoundation2, "cssClasses", {
    get: function() {
      return cssClasses;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTabScrollerFoundation2, "strings", {
    get: function() {
      return strings;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCTabScrollerFoundation2, "defaultAdapter", {
    get: function() {
      return {
        eventTargetMatchesSelector: function() {
          return false;
        },
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        addScrollAreaClass: function() {
          return void 0;
        },
        setScrollAreaStyleProperty: function() {
          return void 0;
        },
        setScrollContentStyleProperty: function() {
          return void 0;
        },
        getScrollContentStyleValue: function() {
          return "";
        },
        setScrollAreaScrollLeft: function() {
          return void 0;
        },
        getScrollAreaScrollLeft: function() {
          return 0;
        },
        getScrollContentOffsetWidth: function() {
          return 0;
        },
        getScrollAreaOffsetWidth: function() {
          return 0;
        },
        computeScrollAreaClientRect: function() {
          return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
        },
        computeScrollContentClientRect: function() {
          return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
        },
        computeHorizontalScrollbarHeight: function() {
          return 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCTabScrollerFoundation2.prototype.init = function() {
    var horizontalScrollbarHeight = this.adapter.computeHorizontalScrollbarHeight();
    this.adapter.setScrollAreaStyleProperty("margin-bottom", -horizontalScrollbarHeight + "px");
    this.adapter.addScrollAreaClass(MDCTabScrollerFoundation2.cssClasses.SCROLL_AREA_SCROLL);
  };
  MDCTabScrollerFoundation2.prototype.getScrollPosition = function() {
    if (this.isRTL()) {
      return this.computeCurrentScrollPositionRTL();
    }
    var currentTranslateX = this.calculateCurrentTranslateX();
    var scrollLeft = this.adapter.getScrollAreaScrollLeft();
    return scrollLeft - currentTranslateX;
  };
  MDCTabScrollerFoundation2.prototype.handleInteraction = function() {
    if (!this.isAnimating) {
      return;
    }
    this.stopScrollAnimation();
  };
  MDCTabScrollerFoundation2.prototype.handleTransitionEnd = function(evt) {
    var evtTarget = evt.target;
    if (!this.isAnimating || !this.adapter.eventTargetMatchesSelector(evtTarget, MDCTabScrollerFoundation2.strings.CONTENT_SELECTOR)) {
      return;
    }
    this.isAnimating = false;
    this.adapter.removeClass(MDCTabScrollerFoundation2.cssClasses.ANIMATING);
  };
  MDCTabScrollerFoundation2.prototype.incrementScroll = function(scrollXIncrement) {
    if (scrollXIncrement === 0) {
      return;
    }
    this.animate(this.getIncrementScrollOperation(scrollXIncrement));
  };
  MDCTabScrollerFoundation2.prototype.incrementScrollImmediate = function(scrollXIncrement) {
    if (scrollXIncrement === 0) {
      return;
    }
    var operation = this.getIncrementScrollOperation(scrollXIncrement);
    if (operation.scrollDelta === 0) {
      return;
    }
    this.stopScrollAnimation();
    this.adapter.setScrollAreaScrollLeft(operation.finalScrollPosition);
  };
  MDCTabScrollerFoundation2.prototype.scrollTo = function(scrollX) {
    if (this.isRTL()) {
      this.scrollToImplRTL(scrollX);
      return;
    }
    this.scrollToImpl(scrollX);
  };
  MDCTabScrollerFoundation2.prototype.getRTLScroller = function() {
    if (!this.rtlScrollerInstance) {
      this.rtlScrollerInstance = this.rtlScrollerFactory();
    }
    return this.rtlScrollerInstance;
  };
  MDCTabScrollerFoundation2.prototype.calculateCurrentTranslateX = function() {
    var transformValue = this.adapter.getScrollContentStyleValue("transform");
    if (transformValue === "none") {
      return 0;
    }
    var match = /\((.+?)\)/.exec(transformValue);
    if (!match) {
      return 0;
    }
    var matrixParams = match[1];
    var _a = __read(matrixParams.split(","), 6), a = _a[0], b = _a[1], c = _a[2], d = _a[3], tx = _a[4], ty = _a[5];
    return parseFloat(tx);
  };
  MDCTabScrollerFoundation2.prototype.clampScrollValue = function(scrollX) {
    var edges = this.calculateScrollEdges();
    return Math.min(Math.max(edges.left, scrollX), edges.right);
  };
  MDCTabScrollerFoundation2.prototype.computeCurrentScrollPositionRTL = function() {
    var translateX = this.calculateCurrentTranslateX();
    return this.getRTLScroller().getScrollPositionRTL(translateX);
  };
  MDCTabScrollerFoundation2.prototype.calculateScrollEdges = function() {
    var contentWidth = this.adapter.getScrollContentOffsetWidth();
    var rootWidth = this.adapter.getScrollAreaOffsetWidth();
    return {
      left: 0,
      right: contentWidth - rootWidth
    };
  };
  MDCTabScrollerFoundation2.prototype.scrollToImpl = function(scrollX) {
    var currentScrollX = this.getScrollPosition();
    var safeScrollX = this.clampScrollValue(scrollX);
    var scrollDelta = safeScrollX - currentScrollX;
    this.animate({
      finalScrollPosition: safeScrollX,
      scrollDelta
    });
  };
  MDCTabScrollerFoundation2.prototype.scrollToImplRTL = function(scrollX) {
    var animation = this.getRTLScroller().scrollToRTL(scrollX);
    this.animate(animation);
  };
  MDCTabScrollerFoundation2.prototype.getIncrementScrollOperation = function(scrollX) {
    if (this.isRTL()) {
      return this.getRTLScroller().incrementScrollRTL(scrollX);
    }
    var currentScrollX = this.getScrollPosition();
    var targetScrollX = scrollX + currentScrollX;
    var safeScrollX = this.clampScrollValue(targetScrollX);
    var scrollDelta = safeScrollX - currentScrollX;
    return {
      finalScrollPosition: safeScrollX,
      scrollDelta
    };
  };
  MDCTabScrollerFoundation2.prototype.animate = function(animation) {
    var _this = this;
    if (animation.scrollDelta === 0) {
      return;
    }
    this.stopScrollAnimation();
    this.adapter.setScrollAreaScrollLeft(animation.finalScrollPosition);
    this.adapter.setScrollContentStyleProperty("transform", "translateX(" + animation.scrollDelta + "px)");
    this.adapter.computeScrollAreaClientRect();
    requestAnimationFrame(function() {
      _this.adapter.addClass(MDCTabScrollerFoundation2.cssClasses.ANIMATING);
      _this.adapter.setScrollContentStyleProperty("transform", "none");
    });
    this.isAnimating = true;
  };
  MDCTabScrollerFoundation2.prototype.stopScrollAnimation = function() {
    this.isAnimating = false;
    var currentScrollPosition = this.getAnimatingScrollPosition();
    this.adapter.removeClass(MDCTabScrollerFoundation2.cssClasses.ANIMATING);
    this.adapter.setScrollContentStyleProperty("transform", "translateX(0px)");
    this.adapter.setScrollAreaScrollLeft(currentScrollPosition);
  };
  MDCTabScrollerFoundation2.prototype.getAnimatingScrollPosition = function() {
    var currentTranslateX = this.calculateCurrentTranslateX();
    var scrollLeft = this.adapter.getScrollAreaScrollLeft();
    if (this.isRTL()) {
      return this.getRTLScroller().getAnimatingScrollPosition(scrollLeft, currentTranslateX);
    }
    return scrollLeft - currentTranslateX;
  };
  MDCTabScrollerFoundation2.prototype.rtlScrollerFactory = function() {
    var initialScrollLeft = this.adapter.getScrollAreaScrollLeft();
    this.adapter.setScrollAreaScrollLeft(initialScrollLeft - 1);
    var newScrollLeft = this.adapter.getScrollAreaScrollLeft();
    if (newScrollLeft < 0) {
      this.adapter.setScrollAreaScrollLeft(initialScrollLeft);
      return new MDCTabScrollerRTLNegative(this.adapter);
    }
    var rootClientRect = this.adapter.computeScrollAreaClientRect();
    var contentClientRect = this.adapter.computeScrollContentClientRect();
    var rightEdgeDelta = Math.round(contentClientRect.right - rootClientRect.right);
    this.adapter.setScrollAreaScrollLeft(initialScrollLeft);
    if (rightEdgeDelta === newScrollLeft) {
      return new MDCTabScrollerRTLReverse(this.adapter);
    }
    return new MDCTabScrollerRTLDefault(this.adapter);
  };
  MDCTabScrollerFoundation2.prototype.isRTL = function() {
    return this.adapter.getScrollContentStyleValue("direction") === "rtl";
  };
  return MDCTabScrollerFoundation2;
}(MDCFoundation);

// node_modules/@material/tab-scroller/util.js
var util_exports = {};
__export(util_exports, {
  computeHorizontalScrollbarHeight: () => computeHorizontalScrollbarHeight
});
var horizontalScrollbarHeight_;
function computeHorizontalScrollbarHeight(documentObj, shouldCacheResult) {
  if (shouldCacheResult === void 0) {
    shouldCacheResult = true;
  }
  if (shouldCacheResult && typeof horizontalScrollbarHeight_ !== "undefined") {
    return horizontalScrollbarHeight_;
  }
  var el = documentObj.createElement("div");
  el.classList.add(cssClasses.SCROLL_TEST);
  documentObj.body.appendChild(el);
  var horizontalScrollbarHeight = el.offsetHeight - el.clientHeight;
  documentObj.body.removeChild(el);
  if (shouldCacheResult) {
    horizontalScrollbarHeight_ = horizontalScrollbarHeight;
  }
  return horizontalScrollbarHeight;
}

// node_modules/@material/tab-scroller/component.js
var MDCTabScroller = function(_super) {
  __extends(MDCTabScroller2, _super);
  function MDCTabScroller2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCTabScroller2.attachTo = function(root) {
    return new MDCTabScroller2(root);
  };
  MDCTabScroller2.prototype.initialize = function() {
    this.area = this.root.querySelector(MDCTabScrollerFoundation.strings.AREA_SELECTOR);
    this.content = this.root.querySelector(MDCTabScrollerFoundation.strings.CONTENT_SELECTOR);
  };
  MDCTabScroller2.prototype.initialSyncWithDOM = function() {
    var _this = this;
    this.handleInteraction = function() {
      _this.foundation.handleInteraction();
    };
    this.handleTransitionEnd = function(evt) {
      _this.foundation.handleTransitionEnd(evt);
    };
    this.area.addEventListener("wheel", this.handleInteraction, applyPassive());
    this.area.addEventListener("touchstart", this.handleInteraction, applyPassive());
    this.area.addEventListener("pointerdown", this.handleInteraction, applyPassive());
    this.area.addEventListener("mousedown", this.handleInteraction, applyPassive());
    this.area.addEventListener("keydown", this.handleInteraction, applyPassive());
    this.content.addEventListener("transitionend", this.handleTransitionEnd);
  };
  MDCTabScroller2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.area.removeEventListener("wheel", this.handleInteraction, applyPassive());
    this.area.removeEventListener("touchstart", this.handleInteraction, applyPassive());
    this.area.removeEventListener("pointerdown", this.handleInteraction, applyPassive());
    this.area.removeEventListener("mousedown", this.handleInteraction, applyPassive());
    this.area.removeEventListener("keydown", this.handleInteraction, applyPassive());
    this.content.removeEventListener("transitionend", this.handleTransitionEnd);
  };
  MDCTabScroller2.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      eventTargetMatchesSelector: function(evtTarget, selector) {
        return matches(evtTarget, selector);
      },
      addClass: function(className) {
        _this.root.classList.add(className);
      },
      removeClass: function(className) {
        _this.root.classList.remove(className);
      },
      addScrollAreaClass: function(className) {
        _this.area.classList.add(className);
      },
      setScrollAreaStyleProperty: function(prop, value) {
        _this.area.style.setProperty(prop, value);
      },
      setScrollContentStyleProperty: function(prop, value) {
        _this.content.style.setProperty(prop, value);
      },
      getScrollContentStyleValue: function(propName) {
        return window.getComputedStyle(_this.content).getPropertyValue(propName);
      },
      setScrollAreaScrollLeft: function(scrollX) {
        return _this.area.scrollLeft = scrollX;
      },
      getScrollAreaScrollLeft: function() {
        return _this.area.scrollLeft;
      },
      getScrollContentOffsetWidth: function() {
        return _this.content.offsetWidth;
      },
      getScrollAreaOffsetWidth: function() {
        return _this.area.offsetWidth;
      },
      computeScrollAreaClientRect: function() {
        return _this.area.getBoundingClientRect();
      },
      computeScrollContentClientRect: function() {
        return _this.content.getBoundingClientRect();
      },
      computeHorizontalScrollbarHeight: function() {
        return computeHorizontalScrollbarHeight(document);
      }
    };
    return new MDCTabScrollerFoundation(adapter);
  };
  MDCTabScroller2.prototype.getScrollPosition = function() {
    return this.foundation.getScrollPosition();
  };
  MDCTabScroller2.prototype.getScrollContentWidth = function() {
    return this.content.offsetWidth;
  };
  MDCTabScroller2.prototype.incrementScroll = function(scrollXIncrement) {
    this.foundation.incrementScroll(scrollXIncrement);
  };
  MDCTabScroller2.prototype.scrollTo = function(scrollX) {
    this.foundation.scrollTo(scrollX);
  };
  return MDCTabScroller2;
}(MDCComponent);

export {
  cssClasses,
  strings,
  MDCTabScrollerFoundation,
  util_exports,
  MDCTabScroller
};
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
//# sourceMappingURL=chunk-IJPERKNI.js.map
